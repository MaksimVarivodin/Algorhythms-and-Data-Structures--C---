#pragma once
#include "Header.h"

template<class T> 
class Deque{


    /////////////////////////////
	//  переменные класса дек  //
	/////////////////////////////

	/* перед класса */
	Elem<T>* front;
	/* задняя часть класса */
	Elem<T>* back;
	/* количество элементов в классе */
	int size;
	/* расположение для сохранения и открытия */
	string Fpath;

	/////////////////////////////



	/////////////////////////
	//  сеттеры и геттеры  //
	/////////////////////////

	/* получение размера */
	void Size(const int& size0) { size = size0; };
    /* установка передней части */
	void Front(Elem<T>* elmnt) { front = elmnt; };
	/* получение задней части */
	Elem<T>* Front() { return front; };
	/* установка задней части */
	void Back(Elem<T>* elmnt) { back = elmnt; };
	/* получение задней части */
	Elem<T>* Back() { return back; };

	/////////////////////////


	
	///////////////////////////////////
	//  методы работы с указателями  //
	///////////////////////////////////

	/* добавить в начало */
	Elem<T>* PushFront();
	/* удалить из начала */
	Elem<T>* PopFront();
	/* добавить в конец */
	Elem<T>* PushBack();
	/* удалить из конца */
	Elem<T>* PopBack();
	/* очистить список */
	void Clear();
	/* поиск элемента */
	Elem<T>* Find(const int & val);

	////////////////////////////////////



	///////////////////////////////////
	//  методы для работы  с файлом  //
	///////////////////////////////////

	/* выбрать слуайное число */
	void Fff(Elem<T>* elmnt);
		/* метод проверки пути к таблицы */
	bool CheckFpath() {
		return Fpath == "" || Fpath.find(".txt") == string::npos;
	};
	/* метод установки и автоматической проверки пути к файлу */
	void SetPath(const string & path = "") {
		Fpath = path;
		bool check = CheckFpath();
		while (check) {
			cout << "Введите путь: ";
			getline(cin, Fpath);
			if (CheckFpath()) {
				check = true;
				cout << "Путь был введен неправильно" << endl;
			}
			else check = false;
		}
	};

	///////////////////////////////////



public:

	//////////////////////////////////
	//  конструкторы и деструкторы  //
	//////////////////////////////////

	/* конструктор по умолчанию */
	Deque()
	{
		front = nullptr;
		back = nullptr;
		size = 0;
		Fpath = "";
	};
	/* конструктор считывания таблицы из файла */
	Deque(const bool open) : Deque{}
	{
		if (open) {
			Open();
		}
	};
	/* конструктор создания таблицы по заданному размеру */
	Deque(const int size0)
	{
		for (int i = 0; i < size0; i++)
			Fff(PushBack());
	};
	/* деструктор */
	~Deque()
	{
		Clear();
	};

	//////////////////////////////////

	

	///////////////////////////////
	//  пять методов по заданию  //
	///////////////////////////////

	/* проверка на пустоту */
	bool Empty() {
		return front == nullptr && back == nullptr && size == 0;
	};
	/* добавление в начало */
	void AddFront();
	/* добавление в конец */
	void AddBack();
	/* вывод искомого элемента */
	void ShowElem(const int & num);
	/* вывод последнего элемента */
	void ShowLast();

	///////////////////////////////
	


	////////////////////////////////////////////////
	//  дополнительные методы для работы с деком  //
	////////////////////////////////////////////////

	/* получение размера */
	int Size() { return size; };
	/* переприсвоение номеров */
	void Renumb();
	/* демонстрация дека */
	void Show();
	/* сохранение таблицы в тхт файл */
	void Save();
	/* открытие таблицы из тхт файла */
	void Open();
	/* проверка на сохранение */
	bool SavedCheck();

	////////////////////////////////////////////////


	//* дружественная функция для проверки ввода: *//

	template<typename t1, typename t2>
	friend void Enter_check(t1& a, const t2& max, const t2& min);

	//_____________________________________________//


};